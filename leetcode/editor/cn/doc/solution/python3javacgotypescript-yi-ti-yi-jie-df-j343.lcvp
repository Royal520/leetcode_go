**æ–¹æ³•ä¸€ï¼šDFS**

æˆ‘ä»¬å¯ä»¥éå†æ•´æ•°çŸ©é˜µ $land$ ä¸­çš„æ¯ä¸ªç‚¹ $(i, j)$ï¼Œå¦‚æœè¯¥ç‚¹çš„å€¼ä¸º $0$ï¼Œåˆ™ä»è¯¥ç‚¹å¼€å§‹è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œç›´åˆ°æœç´¢åˆ°çš„ç‚¹çš„å€¼ä¸ä¸º $0$ï¼Œåˆ™åœæ­¢æœç´¢ï¼Œæ­¤æ—¶æœç´¢åˆ°çš„ç‚¹çš„ä¸ªæ•°å³ä¸ºæ± å¡˜çš„å¤§å°ï¼Œå°†å…¶åŠ å…¥ç­”æ¡ˆæ•°ç»„ä¸­ã€‚

> æ³¨æ„ï¼šåœ¨è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢æ—¶ï¼Œä¸ºäº†é¿å…é‡å¤æœç´¢ï¼Œæˆ‘ä»¬å°†æœç´¢åˆ°çš„ç‚¹çš„å€¼ç½®ä¸º $1$ã€‚

æœ€åï¼Œæˆ‘ä»¬å¯¹ç­”æ¡ˆæ•°ç»„è¿›è¡Œæ’åºï¼Œå³å¯å¾—åˆ°æœ€ç»ˆç­”æ¡ˆã€‚

* [sol1-Python3]

```python
class Solution:
    def pondSizes(self, land: List[List[int]]) -> List[int]:
        def dfs(i: int, j: int) -> int:
            res = 1
            land[i][j] = 1
            for x in range(i - 1, i + 2):
                for y in range(j - 1, j + 2):
                    if 0 <= x < m and 0 <= y < n and land[x][y] == 0:
                        res += dfs(x, y)
            return res

        m, n = len(land), len(land[0])
        return sorted(dfs(i, j) for i in range(m) for j in range(n) if land[i][j] == 0)
```

* [sol1-Java]

```java
class Solution {
    private int m;
    private int n;
    private int[][] land;

    public int[] pondSizes(int[][] land) {
        m = land.length;
        n = land[0].length;
        this.land = land;
        List<Integer> ans = new ArrayList<>();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (land[i][j] == 0) {
                    ans.add(dfs(i, j));
                }
            }
        }
        return ans.stream().sorted().mapToInt(Integer::valueOf).toArray();
    }

    private int dfs(int i, int j) {
        int res = 1;
        land[i][j] = 1;
        for (int x = i - 1; x <= i + 1; ++x) {
            for (int y = j - 1; y <= j + 1; ++y) {
                if (x >= 0 && x < m && y >= 0 && y < n && land[x][y] == 0) {
                    res += dfs(x, y);
                }
            }
        }
        return res;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    vector<int> pondSizes(vector<vector<int>>& land) {
        int m = land.size(), n = land[0].size();
        function<int(int, int)> dfs = [&](int i, int j) -> int {
            int res = 1;
            land[i][j] = 1;
            for (int x = i - 1; x <= i + 1; ++x) {
                for (int y = j - 1; y <= j + 1; ++y) {
                    if (x >= 0 && x < m && y >= 0 && y < n && land[x][y] == 0) {
                        res += dfs(x, y);
                    }
                }
            }
            return res;
        };
        vector<int> ans;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (land[i][j] == 0) {
                    ans.push_back(dfs(i, j));
                }
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```

* [sol1-Go]

```go
func pondSizes(land [][]int) (ans []int) {
	m, n := len(land), len(land[0])
	var dfs func(i, j int) int
	dfs = func(i, j int) int {
		res := 1
		land[i][j] = 1
		for x := i - 1; x <= i+1; x++ {
			for y := j - 1; y <= j+1; y++ {
				if x >= 0 && x < m && y >= 0 && y < n && land[x][y] == 0 {
					res += dfs(x, y)
				}
			}
		}
		return res
	}
	for i := range land {
		for j := range land[i] {
			if land[i][j] == 0 {
				ans = append(ans, dfs(i, j))
			}
		}
	}
	sort.Ints(ans)
	return
}
```

* [sol1-TypeScript]

```ts
function pondSizes(land: number[][]): number[] {
    const m = land.length;
    const n = land[0].length;
    const dfs = (i: number, j: number): number => {
        let res = 1;
        land[i][j] = 1;
        for (let x = i - 1; x <= i + 1; ++x) {
            for (let y = j - 1; y <= j + 1; ++y) {
                if (x >= 0 && x < m && y >= 0 && y < n && land[x][y] === 0) {
                    res += dfs(x, y);
                }
            }
        }
        return res;
    };
    const ans: number[] = [];
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (land[i][j] === 0) {
                ans.push(dfs(i, j));
            }
        }
    }
    ans.sort((a, b) => a - b);
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(m \times n \times \log (m \times n))ï¼Œç©ºé—´å¤æ‚åº¦ O(m \times n)$ã€‚å…¶ä¸­ $m$ å’Œ $n$ åˆ†åˆ«ä¸ºçŸ©é˜µ $land$ çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
